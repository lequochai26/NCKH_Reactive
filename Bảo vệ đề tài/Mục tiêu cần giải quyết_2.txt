1. What is Reactive Programming ?
Reactive Programming là một mô hình lập trình tập trung vào việc phản ứng hay xử lý đối với những sự thay đổi hay những sự kiện được phát ra bởi những luồng dữ liệu bất đồng bộ (asynchronous) một cách non-blocking.

Những khái niệm cót lõi của Reactive Programming:
- Observables:
	+ Khái niệm: Là những luồng dữ liệu bất đồng bộ, thứ mà sẽ phát ra tín hiệu, sự kiện khi: Có dữ liệu mới đã sẵn sàng (next), có lỗi xảy ra (error), đã hoàn thành và không còn dữ liệu mới nào đang chờ (complete). Các Observables được coi là các Publishers trong mẫu thiết kế Publisher - Consumer.
	+ Khởi tạo: Observables có thể được khởi tạo từ các nguồn dữ liệu như: tập dữ liệu, Promises, Timers (bộ đếm thời gian), User inputs (dữ liệu được nhập bởi người dùng), ... 
	+ Các loại Observables:
		. Cold Observables: Là những Observable mà khi có một Observer đăng ký lắng nghe, Observable này sẽ phát lại tín hiệu cho toàn bộ dữ liệu có trong luồng dữ liệu cho Observer đó. Và những Observables này sẽ và chỉ sẽ phát tín hiệu khi tất cả dữ liệu đã sẵn sàng để được phát đi. Có thể nói cách khác thì các Observables này hoạt động theo hướng bị động, tức là việc phát tín hiệu về dữ liệu sẽ được các Observers yêu cầu thay vì các Observables này chủ động phát tín hiệu. Và như thế, cơ chế xử lý quá tải Backpressure-Handling không cần thiết cho các Observables này.
		. Hot Observable: Là những Observable sẽ phát tín hiệu ngay từ khi nó dược khởi tạo và có dữ liệu mới đã sẵn sàng và khi một Observer đăng ký lắng nghe Observable này, chỉ nhận được tín hiệu cho dữ liệu đang phát ở thời điểm đó và sẽ không nhận được tín hiệu cho những dữ liệu đã được phát trước khi Observer này đăng ký. Hay có thể nói cách khác là các Observables này hoạt động theo hướng chủ động, nó sẽ chủ động phát dữ dữ liệu và việc các Observers có nhận được hay không là vấn đề ở chúng. Và việc phát dữ liệu một cách chủ động như vậy có thể sẽ dẫn đến trường hợp khi mà các Observers không kịp xử lý những dữ liệu được phát ra bởi các Observables này và những dữ liệu đó sẽ được lưu vào một hàng đợi dữ liệu hay còn gọi là "Buffer" và cần dùng một cơ chế xử lý quá tải (Backpressure-Handling) nào đó để xử lý chúng.

- Observers: Để có thể nhận và xử lý những tín hiệu do Observable phát ra, cần có những đối tượng Observer để lắng nghe những tín hiệu này và những đối tượng Observer này phải đăng ký lắng nghe từ Observable. Và ngược lại, khi không cần lắng nghe tín hiệu từ Observable nữa, Observer này cũng có thể hủy đăng ký lắng nghe tín hiệu từ một Observable bất kỳ.

- Operators: Là những phương thức được sử dụng để làm biến đổi một Observable, chẳng hạn như: map (chuyển đổi dữ liệu của một Observable), filter (lọc dữ liệu của một Observable), combine (Kết hợp dữ liệu từ một nguồn khác vào Observable), ...

- Backpressure Handling (Xử lý quá tải): Khi làm việc với những nguồn dữ liệu bất đồng bộ như thế này, cụ thể là các Hot Observables, sẽ có những trường hợp khi mà tốc độ phát ra dữ liệu của các Observables nhanh hơn tốc độ xử lý những dữ liệu đã được phát ra đó của Observers. Khi đó thì các dữ liệu chưa dược xử lý kịp bởi Observers sẽ được lưu vào danh sách hàng dợi hay còn gọi là "Buffer" chờ được xử lý bằng một cơ chế Backpressure-Handling nào đó. Tuy nhiên thì kích thước của Buffer này cũng có giới hạn, nếu không có cơ chế xử lý quá tải thích hợp, tình trạng sập hệ thống vì quá tải vẫn có thể diễn ra. Khi đó, việc xử lý quá tải (Backpressure Handling) trở nên cần thiết và quan trọng để đảm bảo tính co giãn cho hệ thống, giúp hệ thống không bị sập vì quá tải và không làm giảm đi hiệu suất xử lý của hệ thống. Mỗi thư viện Reactive Programming đều hỗ trợ những phương pháp xử lý quá tải khác nhau giúp hệ thống luôn hoạt động hiệu quả và ổn định.

- Schedulers: Là những bộ quản lý thời gian cũng như thời điểm mà một tác vụ nào đó được thực thi, chẳng hạn như: Thời điểm phát dữ liệu của một Observable, ... Bộ quản lý thời gian thực thi này là yếu tố chính đảm bảo cho tính bất đồng bộ trong hệ thống Reactive.

1.1. Cơ chế hoạt động của Reactive Programming ?
- Observable đại diện cho một luồng dữ liệu bất đồng bộ, và khi có dữ liệu đã sẵn sàng trong luồng dữ liệu này, Observable sẽ phát tín hiệu về dữ liệu đó đến các Observers đã đăng ký lắng nghe Observable này. Các Observers sẽ nhận lấy các dữ liệu này và xử lý gì đó (bước này gọi là phản ứng hay React). Trong quá trình này, Schedulers sẽ là đối tượng đứng ra xác định xem các Observers nên được thực thi khi nào ? Lúc nào ? Và trên luồng nào ? ... để mang đến khả năng bất đồng bộ cho việc xử lý, phản ứng với sự kiện. Và cũng trong quá trình này, nếu tốc độ phát dữ liệu của Observable nhanh hơn tốc độ xử lý, phản ứng của Observers thì các dữ liệu chưa được Observers xử lý sẽ được đưa vào một danh sách hàng đợi. Nhưng hàng đợi này có giới hạn về sức chứa, nếu quá tải hàng đợi, lúc này các cơ chế Backpressure Handling vào cuộc để xử lý quá tải hàng đợi dữ liệu.



2. What is Reactive System ?
	+ Là một hệ thống đáp ứng 4 tính chất: Responsive, Resilient, Elastic, Message Driven.
	+ Responsive (Tính phản hồi): Hệ thống có thời gian phản hồi nhanh và nhất quán. Ví dụ: Khi truy cập vào ứng dụng / trang web Facebook thì hệ thống lập tức phản hồi cho chúng ta thấy giao diện, mặc dù có thể là những hình ảnh, bài viết chưa được tải lên hết nhưng hệ thống gần như phản hồi ngay lập tức cho ta biết hệ thống vẫn đang hoạt động.
		=> Vì hệ thống Reactive chủ yếu dựa trên việc xử lý luồng dữ liệu một cách bất đồng bộ, nên cung cấp cho hệ thống khả năng phản hồi gần như là ngay lập tức mà không có sự chậm trễ.

	+ Resilient (Tính kiên cố): Hệ thống vẫn ở trong trạng thái ổn định và phản hồi nhanh chóng ngay cả khi gặp sự cố hay lỗi. Ví dụ: Trong một hệ thống lớn như Facebook, việc xảy ra lỗi dưới phần xử lý của hệ thống là chuyện không thể tránh khỏi, vì kích thước hệ thống quá lớn, quá rộng, sức con người không thể nào quản lý hết được, nên việc xảy ra lỗi hoặc gặp sự cố là hoàn toàn có thể xảy ra. Nhưng khi điều đó xảy ra, hệ thống chỉ đơn giản là xuất ra một thông báo lỗi cho người dùng biết là đã gặp sự cố ở phía xử lý và hệ thống vẫn tiếp tục hoạt động bình thường mà không bị ảnh hưởng bởi sự cố kia.
		=> Vì hệ thống Reactive vận hành dựa trên việc xử lý luồng dữ liệu bất đồng bộ và làm việc với những luồng dữ liệu này, khi có lỗi hoặc sự có gì đó xảy ra, lỗi đó sẽ được truyền đi dưới dạng là một thông điệp đến các bộ xử lý đang lắng nghe luồng sự kiện này và vì thế đảm bảo hệ thống luôn trong trạng thái hoạt động và ổn định mà không bị ảnh hưởng bởi lỗi hay sự cố đã xảy ra kia.

	+ Elastic (Tính co giãn): Hệ thống vẫn giữ thời gian phản hồi nhất quán và cố định ngay cả khi chịu tải lớn và không làm ảnh hưởng đến tính ổn định của hệ thống và thời gian phản hồi của hệ thống. Ví dụ: Các trang thương mại điện tử như Amazon vào các dịp khuyến mại lớn thì lượng truy cập rất cao từ khắp các nơi trên thế giới, nhiều đến mức chúng ta cũng không tưởng tượng được con số bao nhiêu. Thế nhưng, ngay cả khi nhiều lượt truy cập được thực hiện như vậy thì hệ thống vẫn phản hồi trong khoảng thời gian rất cố định, nhất quán và hầu như không bị ảnh hưởng gì bởi lượng truy cập khủng đó.
		=> Vì trong các thư viện lập trình Reactive đều có hỗ trợ Backpressure Handling (xử lý quá tải) như đã đề cập ở trên, giúp tài nguyên hệ thống được sử dụng hợp lý và tiết kiệm và từ đó tối ưu hiệu suất xử lý của hệ thống và mang đến thời gian phản hồi nhất quán và không bị ảnh hưởng khi chịu tải lớn trong hệ thống.

	+ Message Driven (Khả năng truyền thông điệp): Khả năng truyền thông điệp giữa các thành phần trong một hệ thống giúp định hình rõ ranh giới giữa các thành phần trong hệ thống, giúp các thành phần trong hệ thống ít phụ thuộc nhau hơn.
		. Nó mang đến TÍNH CO GIÃN cho hệ thống, vì thông qua việc các thành phần trong hệ thống giao tiếp với nhau thông qua các thông điệp, nó giúp cho hệ thống có thể kiểm soát lượng tải thông qua việc quản lý hàng chờ (queue) thông điệp.
		. Nó mang đến TÍNH KIÊN CỐ cho hệ thống, vì thông qua việc các thành phần trong hệ thống giao tiếp với nhau thông qua các thông điệp, nó giúp cho các thành phần trong hệ thống biệt lặp với nhau và ít phụ thuộc nhau nhất có thể. Và khi có sự cố hay lỗi xảy ra ở một thành phần bất kỳ, lỗi đó sẽ được gửi đi cho một thành phần khác xử lý dưới dạng là một thông điệp. Giúp cho hệ thống không bị sập mỗi khi xảy ra lỗi hay sự cố ở một thành phần bất kỳ trong hệ thống.
		. Nó mang đến TÍNH PHẢN HỒI cho hệ thống, vì thông qua việc các thành phần trong hệ thống giao tiếp với nhau thông qua các thông điệp bất đồng bộ, và xử lý chủ yếu dựa trên thông điệp nên thời gian phản hồi lúc nào cũng nhất quán và ổn định, hầu như không có sự chậm trễ.
		. Nó mang đến khả năng quản lý luồng xử lý tốt hơn cho hệ thống thông qua việc xử lý dựa trên thông điệp.



#3. Pros of Reactive Programming ?
- Tối ưu thời gian phản hồi: Vì Reactive Programming chủ yếu dựa trên việc xử lý luồng dữ liệu một cách bất đồng bộ, nên nó cung cấp cho hệ thống khả năng phản hồi gần như là ngay lập tức mà không có sự chậm trễ.
- Đẩy mạnh khả năng phục hồi sau sự cố: Vì Reactive Programming vận hành dựa trên việc xử lý luồng dữ liệu bất đồng bộ và làm việc với những luồng dữ liệu này, khi có lỗi hoặc sự có gì đó xảy ra, lỗi đó sẽ được truyền đi dưới dạng là một thông điệp đến các bộ xử lý đang lắng nghe luồng sự kiện này (observers) và vì thế đảm bảo hệ thống luôn trong trạng thái hoạt động và ổn định mà không bị ảnh hưởng bởi lỗi hay sự cố đã xảy ra kia.
- Tối ưu hóa tài nguyên phần cứng hệ thống: Vì trong các thư viện lập trình Reactive đều có hỗ trợ Backpressure Handling (xử lý quá tải) như đã đề cập ở trên, giúp tài nguyên hệ thống được sử dụng hợp lý và tiết kiệm và từ đó tối ưu hiệu suất xử lý của hệ thống và mang đến thời gian phản hồi nhất quán và không bị ảnh hưởng khi chịu tải lớn trong hệ thống.



#4. Reactive in real-life scenarios ?
- Khả năng phản hồi: Khi truy cập vào ứng dụng / trang web Facebook thì hệ thống lập tức phản hồi cho chúng ta thấy giao diện, mặc dù có thể là những hình ảnh, bài viết chưa được tải lên hết nhưng hệ thống gần như phản hồi ngay lập tức cho ta biết hệ thống vẫn đang hoạt động.
- Khả năng phục hồi sau sự cố: Trong một hệ thống lớn như Facebook, việc xảy ra lỗi dưới phần xử lý của hệ thống là chuyện không thể tránh khỏi, vì kích thước hệ thống quá lớn, quá rộng, sức con người không thể nào quản lý hết được, nên việc xảy ra lỗi hoặc gặp sự cố là hoàn toàn có thể xảy ra. Nhưng khi điều đó xảy ra, hệ thống chỉ đơn giản là xuất ra một thông báo lỗi cho người dùng biết là đã gặp sự cố ở phía xử lý và hệ thống vẫn tiếp tục hoạt động bình thường mà không bị ảnh hưởng bởi sự cố kia.
- Khả năng co giãn: Các trang thương mại điện tử như Amazon vào các dịp khuyến mại lớn thì lượng truy cập rất cao từ khắp các nơi trên thế giới, nhiều đến mức chúng ta cũng không tưởng tượng được con số bao nhiêu. Thế nhưng, ngay cả khi nhiều lượt truy cập được thực hiện như vậy thì hệ thống vẫn phản hồi trong khoảng thời gian rất cố định, nhất quán và hầu như không bị ảnh hưởng gì bởi lượng truy cập khủng đó.



5. What if without Reactive ?
- Nếu không có mô hình lập trình Reactive, hệ thống của chúng ta sẽ gặp các vấn đề về:
	+ Thời gian phản hồi: Vì thông thường, theo các mô hình lập trình trước đây, đa phần mọi tác vụ đều được thực thi một các đồng bộ và blocking. Cụ thể là khi xử lý một các vụ nào đó có rất nhiều bước, nhưng phải xong bước 1 mới đến được bước 2 và cứ như thế đến bước cuối cùng mới phản hồi. Như vậy, thời gian phản hồi của hệ thống sẽ bị kéo dài.
	+ Tính kiên cố: Theo các mô hình lập trình trước đây, việc xử lý lỗi chủ yếu thông qua việc dự đoán, nắm bắt và xử lý một cách thủ công. Nhưng, nếu như vậy, hệ thống không được xử lý lỗi khéo sẽ dẫn đến tình trạng hệ thống bị sập và ngừng hoạt động, không thể phản hồi được nữa.
	+ Tính co giãn: Đối với các mô hình lập trình trước đây, việc quyết định phân bổ tài nguyên phần cứng cho một hệ thống nào đó phụ thuộc vào các yếu tố bên ngoài. Và như thế, thời gian phản hồi hay hiệu suất của hệ thống được quyết định bởi các yếu tố bên ngoài.

- Để có cái nhìn tốt hơn, ta hãy so sánh với các mô hình lập trình trước đây:
	+ Xử lý sự kiện, tác vụ đồng bộ:
		. Reactive Programming: Xử lý các tác vụ bất đồng bộ hiệu quả và kiến trúc mặc định của Reactive Programming là dựa trên việc xử lý sự kiện.
		. Procedural Programming: Gặp rất nhiều vấn đề và khó khăn trong việc quản lý các tác vụ bất đồng bộ.
		. Functional Programming: Cần có các thư viện bổ sung và xử lý kém hiệu quả hơn vì kiến trúc của nó không giống với kiến trúc dựa trên việc xử lý sự kiện như Reactive Programming.
	
	+ Mã nguồn dễ hiểu và rõ ràng:
		. Reactive Programming: Tập trung vào việc phản ứng với những sự thay đổi thay vì tập trung vào việc làm rõ làm thế nào mà điều này có thể thực hiện được. Vì vậy, nên mã nguồn lập trình theo mô hình Reactive Programming tương đối dễ hiểu và khá rõ ràng.
		. Procedural Programming: Thực hiện từng bước step-by-step khiến mã nguồn trở nên phức tạp hơn và khó hiểu hơn vài dài dòng hơn, khó khăn hơn khi làm việc với nó.
		. Functional Programming: Viết mã nguồn chủ yếu bằng việc khai báo và sử dụng hàm nên tương đối dễ đọc, dễ hiểu và cũng khá rõ ràng.

	+ Khả năng co giãn:
		. Reactive Programming: Hỗ trợ sẵn việc quản lý các thông điệp, các sự kiện bất đồng bộ như một phần cốt lõi giúp cũng như hỗ trợ các cơ chế xử lý quá tải giúp mang đến khả năng co giãn tốt cho hệ thống.
		. Procedural Programming: Gặp rất nhiều thử thách trong việc quản lý bất đồng bộ nên không mang đến khả năng co giãn hiệu quả cho hệ thống.
		. Functional Programming: Gặp nhiều vấn đề trong việc quản lý các tác vụ bất đồng bộ cũng như các hoạt động bất đồng bộ. Nên dẫn đến khả năng co giãn của hệ thống không được tốt.

	+ Khả năng phản hồi:
		. Reactive Programming: Tập trung vào việc phản ứng với những sự thay đổi thời gian thực một cách bất đồng bộ, non-blocking nên mang đến thời gian phản hồi nhanh và nhất quán.
		. Procedural Programming: Xử lý các tác vụ blocking từng bước một nên dẫn đến thời gian phản hồi của hệ thống tùy thuộc vào kích thước dữ liệu xử lý.
		. Functional Programming: Xử lý các tác vụ  thông qua các hàm và mặc định thì vẫn theo hướng blocking nên dẫn đến thời gian phản hồi của hệ thống tùy thuộc vào kích thước dữ liệu xử lý.

	+ Sự phức tạp trong việc quản lý dữ liệu
		. Reactive Programming: Xử lý một chuỗi các tác vụ bất đồng bộ nên việc quản lý dữ liệu trở nên phức tạp hơn.
		. Procedural Programming, Functional Programming: Quản lý các dữ liệu thông qua các biến nên đơn giản hơn rất nhiều.

	+ Xử lý lỗi:
		. Reactive Progtramming: Xử lý lỗi thông qua cơ chế truyền thông điệp, nên việc xử lý lỗi sẽ hiệu quả hơn và giúp đảm bảo tính kiên cố của hệ thống.
		. Procedural Programming, Functional Programming: Xử lý lỗi thủ công và phải dự đoán khả năng xảy ra lỗi ở mã nguồn. Dẫn đến khả năng sập khi hệ thống gặp sự cố hoặc lỗi.



6. Why Reactive ?
- Vì nhu cầu của người dùng ngày một cao lên theo sự tiến hóa của môi trường công nghệ. Nên các hệ thống, phần mềm phải phát triển theo để mang đến trải nghiệm người dùng tốt nhất có thể và phải đảm bảo chất lượng dịch vụ lúc nào cũng tốt nhất. Tuy nhiên, ở các mô hình lập trình cũ, hệ thống sẽ gặp rất nhiều các vấn đề về khả năng phản hồi, tính kiên cố, tính co giãn khiến cho chất lượng dịch vụ bị ảnh hưởng, tốn kém chi phí mở rộng tài nguyên phần cứng cũng như không đáp ứng được nhu cầu người dùng ở thị trường công nghệ ngày nay. Nên chúng ta phải áp dụng mô hình lập trình Reactive để mang đến một hệ thống có khả năng phản hồi tốt, một hệ thống có tính kiên cố cao và tính co giãn thật tốt để đáp ứng nhu cầu của thị trường hiện nay.



7. RxJava ?
7.1. Giới thiệu về Reactive X ?
- Reactive X là một dự án tập trung vào việc mang mô hình lập trình Reactive Programming đến với các ngôn ngữ lập trình, môi trường thực thi khác nhau. Trong đó có: Java, JavaScript, C#, Python, ...

7.2. Giới thiệu về RxJava ?
- RxJava là một bản triển khai (implementation) của dự án ReactiveX cho ngôn ngữ cũng như môi trường thực thi Java.

7.2.1. Các thành phần cốt lõi trong RxJava ?
7.2.1.1. Observables ?
- Trong RxJava, các Observables là các bản triển khai (implementation) của các luồng dữ liệu bất đồng bộ (Asynchronous Data Stream) trong định nghĩa của Reactive Programming.
	+ Một số loại Observables: Observable, Flowable, Maybe, Single, ...

7.2.1.2. Observers ?
- Trong RxJava, các Observers sẽ là các đối tượng lắng nghe và sau đó xử lý, phản ứng với sự thay đổi của Observables hay tín hiệu được phát ra từ chúng.

7.2.1.3. Schedulers ?
- Trong RxJava, các Schedulers là các bộ quản lý luồng được sử dụng để tính toán thời điểm cũng như định luồng mà các tác vụ sẽ được thực thi trên đó mang đến khả năng thực thi bất đồng bộ. 
	+ Có một số loại Schedulers: io, computation, 



8. Spring Web Flux ?
8.1. Spring MVC's Architecture vs Spring Web Flux's Architecture ?
9. RxJava vs Web Flux ?
10. Demo ?
10.1. Without Reactive
10.2. With RxJava
=> Must show the uses of RxJava in this demo application
10.3. With Web Flux
=> Must show the uses of Web Flux in this demo application
11. When will this project done ?
12. The cost of this project ?





-- Câu hỏi bên ngoài
1. Tại sao phải dùng Reactive ? Lý do mà Rective Programming ra đời ?
- Vì nhu cầu của người dùng ngày một cao lên theo sự tiến hóa của môi trường công nghệ. Nên các hệ thống, phần mềm phải phát triển theo để mang đến trải nghiệm người dùng tốt nhất có thể và phải đảm bảo chất lượng dịch vụ lúc nào cũng tốt nhất. Tuy nhiên, ở các mô hình lập trình cũ, hệ thống sẽ gặp rất nhiều các vấn đề về khả năng phản hồi, tính kiên cố, tính co giãn khiến cho chất lượng dịch vụ bị ảnh hưởng, tốn kém chi phí mở rộng tài nguyên phần cứng cũng như không đáp ứng được nhu cầu người dùng ở thị trường công nghệ ngày nay. Nên chúng ta phải áp dụng mô hình lập trình Reactive để mang đến một hệ thống có khả năng phản hồi tốt, một hệ thống có tính kiên cố cao và tính co giãn thật tốt để đáp ứng nhu cầu của thị trường hiện nay.

- Nếu không có mô hình lập trình Reactive, hệ thống của chúng ta sẽ gặp các vấn đề về:
	+ Thời gian phản hồi: Vì thông thường, theo các mô hình lập trình trước đây, đa phần mọi tác vụ đều được thực thi một các đồng bộ và blocking. Cụ thể là khi xử lý một các vụ nào đó có rất nhiều bước, nhưng phải xong bước 1 mới đến được bước 2 và cứ như thế đến bước cuối cùng mới phản hồi. Như vậy, thời gian phản hồi của hệ thống sẽ bị kéo dài.
	+ Tính kiên cố: Theo các mô hình lập trình trước đây, việc xử lý lỗi chủ yếu thông qua việc dự đoán, nắm bắt và xử lý một cách thủ công. Nhưng, nếu như vậy, hệ thống không được xử lý lỗi khéo sẽ dẫn đến tình trạng hệ thống bị sập và ngừng hoạt động, không thể phản hồi được nữa.
	+ Tính co giãn: Đối với các mô hình lập trình trước đây, việc quyết định phân bổ tài nguyên phần cứng cho một hệ thống nào đó phụ thuộc vào các yếu tố bên ngoài. Và như thế, thời gian phản hồi hay hiệu suất của hệ thống được quyết định bởi các yếu tố bên ngoài.

2. Tại sao chắc chắn Facebook, Amazon có Reactive ?
- Các hệ thống phầm mềm lớn với lượng dữ liệu khổng lồ ngày nay, để đạt được tốc độ phản hồi nhanh nhất và mang lại trải nghiệm người dùng tốt nhất thì hầu hết đều là Reactive, vì ở thời điểm hiện tại thì Reactive nó đang giữ vai trò chủ đạo giải quyết vấn đề này.
- Front-end của Facebook có sử dụng React.JS (một framework front-end nổi tiếng với khả năng phát triển giao diện sống, phản ứng với tương tác ngay lập tức. Mà để đạt được khả năng phản ứng tốt như vậy của React.JS thì chắc chắn không thể thiếu Reactive)

