1. What is Reactive Programming ?
Reactive Programming là một mô hình lập trình tập trung vào việc phản ứng hay xử lý đối với những sự thay đổi hay những sự kiện được phát ra bởi những luồng dữ liệu bất đồng bộ (asynchronous) một cách non-blocking.

Những khái niệm cót lõi của Reactive Programming:
- Observables:
	+ Khái niệm: Là những luồng dữ liệu bất đồng bộ, thứ mà sẽ phát ra tín hiệu, sự kiện khi: Có dữ liệu mới đã sẵn sàng (next), có lỗi xảy ra (error), đã hoàn thành và không còn dữ liệu mới nào đang chờ (complete). Các Observables được coi là các Publishers trong mẫu thiết kế Publisher - Consumer.
	+ Khởi tạo: Observables có thể được khởi tạo từ các nguồn dữ liệu như: tập dữ liệu, Promises, Timers (bộ đếm thời gian), User inputs (dữ liệu được nhập bởi người dùng), ... 
	+ Các loại Observables:
		. Cold Observables: Là những Observable mà khi có một Observer đăng ký lắng nghe, Observable này sẽ phát lại tín hiệu cho toàn bộ dữ liệu có trong luồng dữ liệu cho Observer đó. Và những Observables này sẽ và chỉ sẽ phát tín hiệu khi tất cả dữ liệu đã sẵn sàng để được phát đi. Có thể nói cách khác thì các Observables này hoạt động theo hướng bị động, tức là việc phát tín hiệu về dữ liệu sẽ được các Observers yêu cầu thay vì các Observables này chủ động phát tín hiệu. Và như thế, cơ chế xử lý quá tải Backpressure-Handling không cần thiết cho các Observables này.
		. Hot Observable: Là những Observable sẽ phát tín hiệu ngay từ khi nó dược khởi tạo và có dữ liệu mới đã sẵn sàng và khi một Observer đăng ký lắng nghe Observable này, chỉ nhận được tín hiệu cho dữ liệu đang phát ở thời điểm đó và sẽ không nhận được tín hiệu cho những dữ liệu đã được phát trước khi Observer này đăng ký. Hay có thể nói cách khác là các Observables này hoạt động theo hướng chủ động, nó sẽ chủ động phát dữ dữ liệu và việc các Observers có nhận được hay không là vấn đề ở chúng. Và việc phát dữ liệu một cách chủ động như vậy có thể sẽ dẫn đến trường hợp khi mà các Observers không kịp xử lý những dữ liệu được phát ra bởi các Observables này và những dữ liệu đó sẽ được lưu vào một hàng đợi dữ liệu hay còn gọi là "Buffer" và cần dùng một cơ chế xử lý quá tải (Backpressure-Handling) nào đó để xử lý chúng.
	+ Cơ chế hoạt động: ...

- Observers: Để có thể nhận và xử lý những tín hiệu do Observable phát ra, cần có những đối tượng Observer để lắng nghe những tín hiệu này và những đối tượng Observer này phải đăng ký lắng nghe từ Observable. Và ngược lại, khi không cần lắng nghe tín hiệu từ Observable nữa, Observer này cũng có thể hủy đăng ký lắng nghe tín hiệu từ một Observable bất kỳ.
	+ Cơ chế hoạt động: ...

- Operators: Là những phương thức được sử dụng để làm biến đổi một Observable, chẳng hạn như: map (chuyển đổi dữ liệu của một Observable), filter (lọc dữ liệu của một Observable), combine (Kết hợp dữ liệu từ một nguồn khác vào Observable), ...
	+ Cơ chế hoạt động: ...

- Backpressure Handling (Xử lý quá tải): Khi làm việc với những nguồn dữ liệu bất đồng bộ như thế này, cụ thể là các Hot Observables, sẽ có những trường hợp khi mà tốc độ phát ra dữ liệu của các Observables nhanh hơn tốc độ xử lý những dữ liệu đã được phát ra đó của Observers. Khi đó thì các dữ liệu chưa dược xử lý kịp bởi Observers sẽ được lưu vào danh sách hàng dợi hay còn gọi là "Buffer" chờ được xử lý bằng một cơ chế Backpressure-Handling nào đó. Tuy nhiên thì kích thước của Buffer này cũng có giới hạn, nếu không có cơ chế xử lý quá tải thích hợp, tình trạng sập hệ thống vì quá tải vẫn có thể diễn ra. Khi đó, việc xử lý quá tải (Backpressure Handling) trở nên cần thiết và quan trọng để đảm bảo tính co giãn cho hệ thống, giúp hệ thống không bị sập vì quá tải và không làm giảm đi hiệu suất xử lý của hệ thống. Mỗi thư viện Reactive Programming đều hỗ trợ những phương pháp xử lý quá tải khác nhau giúp hệ thống luôn hoạt động hiệu quả và ổn định.
	+ Cơ chế hoạt động: ...

- Schedulers: Là các bộ quản lý luồng giúp xác định luồng và thời điểm một tác vụ Reactive nào đó sẽ được thực thi. Trong đó, các tác vụ có thể là: Observer đăng ký lắng nghe Observable, Observable phát dữ liệu, Biến đổi (transformation) một luồng dữ liệu, ...
	+ Cơ chế hoạt động: ...

2. What is Reactive System ?
	+ Là một hệ thống đáp ứng 4 tính chất: Responsive, Resilient, Elastic, Message Driven.
	+ Responsive (Tính phản hồi): Hệ thống có thời gian phản hồi nhanh và nhất quán. Ví dụ: Khi truy cập vào ứng dụng / trang web Facebook thì hệ thống lập tức phản hồi cho chúng ta thấy giao diện, mặc dù có thể là những hình ảnh, bài viết chưa được tải lên hết nhưng hệ thống gần như phản hồi ngay lập tức cho ta biết hệ thống vẫn đang hoạt động.
		=> Vì hệ thống Reactive chủ yếu dựa trên việc xử lý luồng dữ liệu một cách bất đồng bộ, nên cung cấp cho hệ thống khả năng phản hồi gần như là ngay lập tức mà không có sự chậm trễ.

	+ Resilient (Tính kiên cố): Hệ thống vẫn ở trong trạng thái ổn định và phản hồi nhanh chóng ngay cả khi gặp sự cố hay lỗi. Ví dụ: Trong một hệ thống lớn như Facebook, việc xảy ra lỗi dưới phần xử lý của hệ thống là chuyện không thể tránh khỏi, vì kích thước hệ thống quá lớn, quá rộng, sức con người không thể nào quản lý hết được, nên việc xảy ra lỗi hoặc gặp sự cố là hoàn toàn có thể xảy ra. Nhưng khi điều đó xảy ra, hệ thống chỉ đơn giản là xuất ra một thông báo lỗi cho người dùng biết là đã gặp sự cố ở phía xử lý và hệ thống vẫn tiếp tục hoạt động bình thường mà không bị ảnh hưởng bởi sự cố kia.
		=> Vì hệ thống Reactive vận hành dựa trên việc xử lý luồng dữ liệu bất đồng bộ và làm việc với những luồng dữ liệu này, khi có lỗi hoặc sự có gì đó xảy ra, lỗi đó sẽ được truyền đi dưới dạng là một thông điệp đến các bộ xử lý đang lắng nghe luồng sự kiện này và vì thế đảm bảo hệ thống luôn trong trạng thái hoạt động và ổn định mà không bị ảnh hưởng bởi lỗi hay sự cố đã xảy ra kia.

	+ Elastic (Tính co giãn): Hệ thống vẫn giữ thời gian phản hồi nhất quán và cố định ngay cả khi chịu tải lớn và không làm ảnh hưởng đến tính ổn định của hệ thống và thời gian phản hồi của hệ thống. Ví dụ: Các trang thương mại điện tử như Amazon vào các dịp khuyến mại lớn thì lượng truy cập rất cao từ khắp các nơi trên thế giới, nhiều đến mức chúng ta cũng không tưởng tượng được con số bao nhiêu. Thế nhưng, ngay cả khi nhiều lượt truy cập được thực hiện như vậy thì hệ thống vẫn phản hồi trong khoảng thời gian rất cố định, nhất quán và hầu như không bị ảnh hưởng gì bởi lượng truy cập khủng đó.
		=> Vì trong các thư viện lập trình Reactive đều có hỗ trợ Backpressure Handling (xử lý quá tải) như đã đề cập ở trên, giúp tài nguyên hệ thống được sử dụng hợp lý và tiết kiệm và từ đó tối ưu hiệu suất xử lý của hệ thống và mang đến thời gian phản hồi nhất quán và không bị ảnh hưởng khi chịu tải lớn trong hệ thống.

	+ Message Driven (Khả năng truyền thông điệp): Khả năng truyền thông điệp giữa các thành phần trong một hệ thống giúp định hình rõ ranh giới giữa các thành phần trong hệ thống, giúp các thành phần trong hệ thống ít phụ thuộc nhau hơn.
		. Nó mang đến TÍNH CO GIÃN cho hệ thống, vì thông qua việc các thành phần trong hệ thống giao tiếp với nhau thông qua các thông điệp, nó giúp cho hệ thống có thể kiểm soát lượng tải thông qua việc quản lý hàng chờ (queue) thông điệp.
		. Nó mang đến TÍNH KIÊN CỐ cho hệ thống, vì thông qua việc các thành phần trong hệ thống giao tiếp với nhau thông qua các thông điệp, nó giúp cho các thành phần trong hệ thống biệt lặp với nhau và ít phụ thuộc nhau nhất có thể. Và khi có sự cố hay lỗi xảy ra ở một thành phần bất kỳ, lỗi đó sẽ được gửi đi cho một thành phần khác xử lý dưới dạng là một thông điệp. Giúp cho hệ thống không bị sập mỗi khi xảy ra lỗi hay sự cố ở một thành phần bất kỳ trong hệ thống.
		. Nó mang đến TÍNH PHẢN HỒI cho hệ thống, vì thông qua việc các thành phần trong hệ thống giao tiếp với nhau thông qua các thông điệp bất đồng bộ, và xử lý chủ yếu dựa trên thông điệp nên thời gian phản hồi lúc nào cũng nhất quán và ổn định, hầu như không có sự chậm trễ.
		. Nó mang đến khả năng quản lý luồng xử lý tốt hơn cho hệ thống thông qua việc xử lý dựa trên thông điệp.



#3. Pros of Reactive Programming ?
- Tối ưu thời gian phản hồi: Vì Reactive Programming chủ yếu dựa trên việc xử lý luồng dữ liệu một cách bất đồng bộ, nên nó cung cấp cho hệ thống khả năng phản hồi gần như là ngay lập tức mà không có sự chậm trễ.
- Đẩy mạnh khả năng phục hồi sau sự cố: Vì Reactive Programming vận hành dựa trên việc xử lý luồng dữ liệu bất đồng bộ và làm việc với những luồng dữ liệu này, khi có lỗi hoặc sự có gì đó xảy ra, lỗi đó sẽ được truyền đi dưới dạng là một thông điệp đến các bộ xử lý đang lắng nghe luồng sự kiện này (observers) và vì thế đảm bảo hệ thống luôn trong trạng thái hoạt động và ổn định mà không bị ảnh hưởng bởi lỗi hay sự cố đã xảy ra kia.
- Tối ưu hóa tài nguyên phần cứng hệ thống: Vì trong các thư viện lập trình Reactive đều có hỗ trợ Backpressure Handling (xử lý quá tải) như đã đề cập ở trên, giúp tài nguyên hệ thống được sử dụng hợp lý và tiết kiệm và từ đó tối ưu hiệu suất xử lý của hệ thống và mang đến thời gian phản hồi nhất quán và không bị ảnh hưởng khi chịu tải lớn trong hệ thống.



#4. Reactive in real-life scenarios ?
- Khả năng phản hồi: Khi truy cập vào ứng dụng / trang web Facebook thì hệ thống lập tức phản hồi cho chúng ta thấy giao diện, mặc dù có thể là những hình ảnh, bài viết chưa được tải lên hết nhưng hệ thống gần như phản hồi ngay lập tức cho ta biết hệ thống vẫn đang hoạt động.
- Khả năng phục hồi sau sự cố: Trong một hệ thống lớn như Facebook, việc xảy ra lỗi dưới phần xử lý của hệ thống là chuyện không thể tránh khỏi, vì kích thước hệ thống quá lớn, quá rộng, sức con người không thể nào quản lý hết được, nên việc xảy ra lỗi hoặc gặp sự cố là hoàn toàn có thể xảy ra. Nhưng khi điều đó xảy ra, hệ thống chỉ đơn giản là xuất ra một thông báo lỗi cho người dùng biết là đã gặp sự cố ở phía xử lý và hệ thống vẫn tiếp tục hoạt động bình thường mà không bị ảnh hưởng bởi sự cố kia.
- Khả năng co giãn: Các trang thương mại điện tử như Amazon vào các dịp khuyến mại lớn thì lượng truy cập rất cao từ khắp các nơi trên thế giới, nhiều đến mức chúng ta cũng không tưởng tượng được con số bao nhiêu. Thế nhưng, ngay cả khi nhiều lượt truy cập được thực hiện như vậy thì hệ thống vẫn phản hồi trong khoảng thời gian rất cố định, nhất quán và hầu như không bị ảnh hưởng gì bởi lượng truy cập khủng đó.



5. What if without Reactive ?
- Nếu không có mô hình lập trình Reactive, hệ thống của chúng ta sẽ gặp các vấn đề về:
	+ Thời gian phản hồi: Vì thông thường, theo các mô hình lập trình trước đây, đa phần mọi tác vụ đều được thực thi một các đồng bộ và blocking. Cụ thể là khi xử lý một các vụ nào đó có rất nhiều bước, nhưng phải xong bước 1 mới đến được bước 2 và cứ như thế đến bước cuối cùng mới phản hồi. Như vậy, thời gian phản hồi của hệ thống sẽ bị kéo dài.
	+ Tính kiên cố: Theo các mô hình lập trình trước đây, việc xử lý lỗi chủ yếu thông qua việc dự đoán, nắm bắt và xử lý một cách thủ công. Nhưng, nếu như vậy, hệ thống không được xử lý lỗi khéo sẽ dẫn đến tình trạng hệ thống bị sập và ngừng hoạt động, không thể phản hồi được nữa.
	+ Tính co giãn: Đối với các mô hình lập trình trước đây, việc quyết định phân bổ tài nguyên phần cứng cho một hệ thống nào đó phụ thuộc vào các yếu tố bên ngoài. Và như thế, thời gian phản hồi hay hiệu suất của hệ thống được quyết định bởi các yếu tố bên ngoài.

- Để có cái nhìn tốt hơn, ta hãy so sánh với các mô hình lập trình trước đây:
	+ Xử lý sự kiện, tác vụ đồng bộ:
		. Reactive Programming: Xử lý các tác vụ bất đồng bộ hiệu quả và kiến trúc mặc định của Reactive Programming là dựa trên việc xử lý sự kiện.
		. Procedural Programming: Gặp rất nhiều vấn đề và khó khăn trong việc quản lý các tác vụ bất đồng bộ.
		. Functional Programming: Cần có các thư viện bổ sung và xử lý kém hiệu quả hơn vì kiến trúc của nó không giống với kiến trúc dựa trên việc xử lý sự kiện như Reactive Programming.
	
	+ Mã nguồn dễ hiểu và rõ ràng:
		. Reactive Programming: Tập trung vào việc phản ứng với những sự thay đổi thay vì tập trung vào việc làm rõ làm thế nào mà điều này có thể thực hiện được. Vì vậy, nên mã nguồn lập trình theo mô hình Reactive Programming tương đối dễ hiểu và khá rõ ràng.
		. Procedural Programming: Thực hiện từng bước step-by-step khiến mã nguồn trở nên phức tạp hơn và khó hiểu hơn vài dài dòng hơn, khó khăn hơn khi làm việc với nó.
		. Functional Programming: Viết mã nguồn chủ yếu bằng việc khai báo và sử dụng hàm nên tương đối dễ đọc, dễ hiểu và cũng khá rõ ràng.

	+ Khả năng co giãn:
		. Reactive Programming: Hỗ trợ sẵn việc quản lý các thông điệp, các sự kiện bất đồng bộ như một phần cốt lõi giúp cũng như hỗ trợ các cơ chế xử lý quá tải giúp mang đến khả năng co giãn tốt cho hệ thống.
		. Procedural Programming: Gặp rất nhiều thử thách trong việc quản lý bất đồng bộ nên không mang đến khả năng co giãn hiệu quả cho hệ thống.
		. Functional Programming: Gặp nhiều vấn đề trong việc quản lý các tác vụ bất đồng bộ cũng như các hoạt động bất đồng bộ. Nên dẫn đến khả năng co giãn của hệ thống không được tốt.

	+ Khả năng phản hồi:
		. Reactive Programming: Tập trung vào việc phản ứng với những sự thay đổi thời gian thực một cách bất đồng bộ, non-blocking nên mang đến thời gian phản hồi nhanh và nhất quán.
		. Procedural Programming: Xử lý các tác vụ blocking từng bước một nên dẫn đến thời gian phản hồi của hệ thống tùy thuộc vào kích thước dữ liệu xử lý.
		. Functional Programming: Xử lý các tác vụ  thông qua các hàm và mặc định thì vẫn theo hướng blocking nên dẫn đến thời gian phản hồi của hệ thống tùy thuộc vào kích thước dữ liệu xử lý.

	+ Sự phức tạp trong việc quản lý dữ liệu
		. Reactive Programming: Xử lý một chuỗi các tác vụ bất đồng bộ nên việc quản lý dữ liệu trở nên phức tạp hơn.
		. Procedural Programming, Functional Programming: Quản lý các dữ liệu thông qua các biến nên đơn giản hơn rất nhiều.

	+ Xử lý lỗi:
		. Reactive Progtramming: Xử lý lỗi thông qua cơ chế truyền thông điệp, nên việc xử lý lỗi sẽ hiệu quả hơn và giúp đảm bảo tính kiên cố của hệ thống.
		. Procedural Programming, Functional Programming: Xử lý lỗi thủ công và phải dự đoán khả năng xảy ra lỗi ở mã nguồn. Dẫn đến khả năng sập khi hệ thống gặp sự cố hoặc lỗi.



6. Why Reactive ?
- Vì nhu cầu của người dùng ngày một cao lên theo sự tiến hóa của môi trường công nghệ. Nên các hệ thống, phần mềm phải phát triển theo để mang đến trải nghiệm người dùng tốt nhất có thể và phải đảm bảo chất lượng dịch vụ lúc nào cũng tốt nhất. Tuy nhiên, ở các mô hình lập trình cũ, hệ thống sẽ gặp rất nhiều các vấn đề về khả năng phản hồi, tính kiên cố, tính co giãn khiến cho chất lượng dịch vụ bị ảnh hưởng, tốn kém chi phí mở rộng tài nguyên phần cứng cũng như không đáp ứng được nhu cầu người dùng ở thị trường công nghệ ngày nay. Nên chúng ta phải áp dụng mô hình lập trình Reactive để mang đến một hệ thống có khả năng phản hồi tốt, một hệ thống có tính kiên cố cao và tính co giãn thật tốt để đáp ứng nhu cầu của thị trường hiện nay.



7. RxJava ?
7.1. Giới thiệu về Reactive X ?
- Reactive X là một dự án tập trung vào việc mang mô hình lập trình Reactive Programming đến với các ngôn ngữ lập trình, môi trường thực thi khác nhau. Trong đó có: Java, JavaScript, C#, Python, ...

7.2. Giới thiệu về RxJava ?
- RxJava là một bản triển khai (implementation) của dự án ReactiveX cho ngôn ngữ cũng như môi trường thực thi Java.

7.2.1. Các thành phần cốt lõi trong RxJava ?
7.2.1.1. Observables ?
- Khái niệm: Trong RxJava, các Observables là các bản triển khai (implementation) của các luồng dữ liệu bất đồng bộ (Asynchronous Data Stream) trong định nghĩa của Reactive Programming.
	+ Một số loại Observables: Observable, Maybe, Single, Flowable, ...
		. Observable: Đại diện cho một luồng dữ liệu trong đó có 0 - N dữ liệu. Là một loại Cold Observable.
		. Maybe: Đại diện cho một luồng dữ liệu mà trong đó có 0 - 1 dữ liệu. Là một loại Cold Observable.
		. Single: Đại diện cho một luồng dữ liệu mà trong đó chỉ và phải có 1 dữ liệu. Là một loại Cold Observable.
		. Flowable: Đại diện cho một luồng dữ liệu, trong đó có có 0 - N dữ liệu tương tự như Observable. Nhưng, Flowable được thiết kế để xử lý quá tải (Backpressure-Handling). Là một loại Observable mà vừa có thể là Cold Observable cũng vừa có thể là Hot Observable.
			=> Nó sẽ là Cold Observable nếu được khởi tạo như thông thường giống Observable.
			=> Nó sẽ là Hot Observable nếu được khỏi tạo bằng phương thức publish() hay share().
- Khởi tạo: Các Observables được khỏi tạo thông qua các phương thức tĩnh như: from, just, ... từ các lớp Observables muốn khởi tạo. Ví dụ: Single.just(1) => Trả ra một Observable thuộc kiểu Single có dữ liệu duy nhất tồn tại trong nó là 1.
- Đăng ký cho phép Observer lắng nghe: Gọi phương thức subscribe và truyền vào một đối tượng Observer tương ứng với Observable này làm tham số cho phương thức.
- Áp dụng bộ quản lý luồng: Gọi phương thức observeOn và truyền vào một đối tượng Scheduler.

7.2.1.2. Observers ?
- Khái niệm: Trong RxJava, các Observers sẽ là các đối tượng lắng nghe và sau đó xử lý, phản ứng với sự thay đổi của Observables hay tín hiệu được phát ra từ chúng.
- Khởi tạo: Các Observers có thể được khỏi tạo thông qua các interface như Consumer, hay Observer dành cho một kiểu Observable cụ thể. Ví dụ: Observer cho Observable, SingleObserver cho Single, MaybeObserver cho Maybe và FlowableObserver cho Flowable, ...
- Đăng ký lắng nghe: Gọi phương thức subscribe của các Observables và truyền Observer làm tham số cho phương thức đó.


7.2.1.3. Operators ?
- Khái niệm: Là các phương thức thuộc một Observable, cho phép làm biến đổi một Observable hoặc làm biến đổi dãy dữ liệu của Observable.
- Một số operators thường dùng như là: filter, map, groupBy, ...
	+ filter: Lọc dãy dữ liệu của Observable dựa trên điều kiện được xác định bởi một đối tượng implement interface Predicate. Từ đó tạo ra một Observable mới chứa dãy dữ liệu đã lọc đó và trả ra Observable mới tạo đó.
	+ map: Làm biến đổi dãy dữ liệu của Observable bằng cách áp dụng một hàm biến đổi (được người dùng định nghĩa bằng đối tượng implement interface Function) lên từng dữ liệu trên dãy dữ liệu của Observable và sau đó tạo ra một đối tượng Observable mới chứa dãy dữ liệu sau khi biến đổi đó và trả ra Observable mới tạo đó.
	+ groupBy: Phân loại hay phân nhóm dữ liệu của Observable dựa trên tiêu chí phân nhóm được người dùng định nghĩa thông qua một đối tượng implement interface Function.

7.2.1.3. Schedulers ?
- Trong RxJava, các Schedulers là các bộ quản lý luồng được sử dụng để tính toán thời điểm cũng như định luồng mà các tác vụ sẽ được thực thi trên đó mang đến khả năng thực thi bất đồng bộ. Những tác vụ đó có thể là: Việc một Observer đăng ký lắng nghe một Observable, việc một Observable phát dữ liệu, hoặc là việc thực hiện biến đổi một Observable, ...
	+ Có một số loại Schedulers được sử dụng phổ biến như: io, computation, single, newThread
		. Schedulers.io: Quản lý các luồng để thực thi các tác vụ liên quan đến nhập / xuất (I/O). Ví dụ: Đọc file, lấy dữ liệu từ mạng internet, ...
		. Schedulers.computation: Quản lý các luồng để thực thi các tác vụ liên quan đến tính toán có sử dụng tài nguyên CPU. Ví dụ: Tính toán phức tạp, Xử lý dữ liệu, ...
		. Schedulers.single: 
		. Schedulers.newThread: 



8. Spring Web Flux ?
8.1. Spring MVC's Architecture vs Spring Web Flux's Architecture ?
9. RxJava vs Web Flux ?
10. Demo ?
10.1. Without Reactive
10.2. With RxJava
=> Must show the uses of RxJava in this demo application
10.3. With Web Flux
=> Must show the uses of Web Flux in this demo application
11. When will this project done ?
12. The cost of this project ?





-- Câu hỏi bên ngoài
1. Tại sao phải dùng Reactive ? Lý do mà Rective Programming ra đời ?
- Vì nhu cầu của người dùng ngày một cao lên theo sự tiến hóa của môi trường công nghệ. Nên các hệ thống, phần mềm phải phát triển theo để mang đến trải nghiệm người dùng tốt nhất có thể và phải đảm bảo chất lượng dịch vụ lúc nào cũng tốt nhất. Tuy nhiên, ở các mô hình lập trình cũ, hệ thống sẽ gặp rất nhiều các vấn đề về khả năng phản hồi, tính kiên cố, tính co giãn khiến cho chất lượng dịch vụ bị ảnh hưởng, tốn kém chi phí mở rộng tài nguyên phần cứng cũng như không đáp ứng được nhu cầu người dùng ở thị trường công nghệ ngày nay. Nên chúng ta phải áp dụng mô hình lập trình Reactive để mang đến một hệ thống có khả năng phản hồi tốt, một hệ thống có tính kiên cố cao và tính co giãn thật tốt để đáp ứng nhu cầu của thị trường hiện nay.

- Nếu không có mô hình lập trình Reactive, hệ thống của chúng ta sẽ gặp các vấn đề về:
	+ Thời gian phản hồi: Vì thông thường, theo các mô hình lập trình trước đây, đa phần mọi tác vụ đều được thực thi một các đồng bộ và blocking. Cụ thể là khi xử lý một các vụ nào đó có rất nhiều bước, nhưng phải xong bước 1 mới đến được bước 2 và cứ như thế đến bước cuối cùng mới phản hồi. Như vậy, thời gian phản hồi của hệ thống sẽ bị kéo dài.
	+ Tính kiên cố: Theo các mô hình lập trình trước đây, việc xử lý lỗi chủ yếu thông qua việc dự đoán, nắm bắt và xử lý một cách thủ công. Nhưng, nếu như vậy, hệ thống không được xử lý lỗi khéo sẽ dẫn đến tình trạng hệ thống bị sập và ngừng hoạt động, không thể phản hồi được nữa.
	+ Tính co giãn: Đối với các mô hình lập trình trước đây, việc quyết định phân bổ tài nguyên phần cứng cho một hệ thống nào đó phụ thuộc vào các yếu tố bên ngoài. Và như thế, thời gian phản hồi hay hiệu suất của hệ thống được quyết định bởi các yếu tố bên ngoài.

2. Tại sao chắc chắn Facebook, Amazon có Reactive ?
- Các hệ thống phầm mềm lớn với lượng dữ liệu khổng lồ ngày nay, để đạt được tốc độ phản hồi nhanh nhất và mang lại trải nghiệm người dùng tốt nhất thì hầu hết đều là Reactive, vì ở thời điểm hiện tại thì Reactive nó đang giữ vai trò chủ đạo giải quyết vấn đề này.
- Front-end của Facebook có sử dụng React.JS (một framework front-end nổi tiếng với khả năng phát triển giao diện sống, phản ứng với tương tác ngay lập tức. Mà để đạt được khả năng phản ứng tốt như vậy của React.JS thì chắc chắn không thể thiếu Reactive)

